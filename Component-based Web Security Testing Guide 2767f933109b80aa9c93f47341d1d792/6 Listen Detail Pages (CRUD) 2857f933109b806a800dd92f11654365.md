# 6. Listen / Detail Pages (CRUD)

# Kapitel: Listen / Detail Pages (CRUD)

**Ziel**

Prüfen, dass List- und Detail-Endpoints korrekt autorisieren, keine Massen-Datenleaks erlauben, Filter/Sort-Parameter nicht zu Injection führen und Pagination-/Export-Funktionen nicht für DoS oder Data-Poisoning missbraucht werden können.

**Scope / Prüfbereiche**

- ACL pro Item (owner vs other).
- Filter / Ordering / Search-Parameter (Injection in DB / Elastic).
- Pagination (limit/offset) — Large offset abuse, cursor vs offset.
- Export-Endpoints (CSV/Excel/PDF) — CSV/Formula Injection, Sensitive data exposure.
- Bulk-operations / CRUD via tampered IDs.
- Caching & pagination headers.

**WSTG-Mapping (relevante Bereiche)**

- Authorization / Access Control (IDOR, horizontal/vertical privilege).
- Input Validation / Injection (WSTG-INPV, testing for SQL/NoSQL/Elastic injection).
- Denial of Service / Resource Exhaustion (WSTG-BUSL / performance-related tests).
- Data Export / Sensitive Data Exposure (WSTG-DATA / information disclosure).
- Session & Auth checks for each read/update endpoint.

---

## Testfälle (Kurzliste mit IDs)

- **LD-01** — IDOR auf Item-Detail: `GET /items/{id}` als fremder Benutzer.
- **LD-02** — CRUD Privilege Bypass: `PUT/DELETE /items/{id}` durch ID-Tampering.
- **LD-03** — Filter / Sort Injection: injection in `?q=...`, `?sort=...` leading to DB/ES injection.
- **LD-04** — CSV/Export: Formula/CSV Injection (z. B. `=CMD('...')` or `@`/`+`/ leading cell formulas).
- **LD-05** — Large offset / limit → resource exhaustion / DoS.
- **LD-06** — Bulk endpoints: mass update / delete without per-row ACL checks.
- **LD-07** — Caching/Cache-poisoning exposing private pages to other users.

---

## Detaillierte Testfälle — Schritte, Hints, Erwartetes Ergebnis

### LD-01 — IDOR auf Item-Detail (GET `/items/{id}`)

**WSTG-Mapping:** Authorization / IDOR tests.

**Schritte**

1. Login als User A.
2. Finde/oder errate Item IDs (z. B. inkrementell: 1,2,3... oder via index) oder nutze vorherige Listenantworten.
3. `GET /items/{id_B}` (id_B gehört User B) → prüfe, ob sensitive Felder zurückgegeben werden (E-Mail, private Notizen, PII).
4. Teste alternative Endpunkte (`/api/items/details?id=...`, `/item?uuid=...`) und different payload encodings.

**Automation-Hint**

- Script: iteriere über ID-Range, logge HTTP Status & Response size → auffällige Responses filtern. ffuf/dirbrute für endpoints.
    
    **Erwartet / Beweis**
    
- 403/404 für nicht autorisierte Zugriffe; keine PII in Responses. Beweis: raw requests + responses.

**Quick-Fix**

- Serverseitige Ownership-Checks: `if (item.ownerId !== session.userId && !caller.isAdmin) return 403`.

---

### LD-02 — CRUD Privilege Bypass via ID-Tampering

**WSTG-Mapping:** Authorization & Business logic.

**Schritte**

1. Als normaler User A intercepte `PUT /items/{A}` update request.
2. Ändere `id` in URL oder im Request-Body auf `id_B` (anderer Benutzer) und sende.
3. Prüfe ob Änderung durchgeführt wurde (GET /items/{id_B}).
4. Wiederhole für `DELETE` / `PATCH`.

**Automation-Hint**

- Burp Intruder für viele ID-Permutationstests.
    
    **Erwartet / Beweis**
    
- Server lehnt persistierende Änderungen ab (403), DB unverändert. Beweis: raw req/res, DB-dumps if accessible.

**Remediation**

- Authorize per request on server; separate update endpoints for admin vs user; validate allowed fields.

---

### LD-03 — Filter / Sorting Injection (SQL / NoSQL / Elastic)

**WSTG-Mapping:** Input Validation / Injection (WSTG-INPV).

**Schritte**

1. Untersuche Filter-Parameter wie `?q=`, `?filter=`, `?sort=` und Parameter-Parsing (are they fed into SQL/ES?).
2. Teste SQLi/NoSQL/Query-DSL payloads: boolean/time-based or ES query injection constructs. Beispiele: `' OR 1=1 --`, `{"query":{"match_all":{}}}` via param injection where supported.
3. Teste specially crafted sort params: `?sort=created_at; DROP TABLE users;--` (be cautious/authorized).
4. Überprüfe ob returned results change or backend errors appear.

**Automation-Hint**

- sqlmap for suspected SQL endpoints (with request file); custom scripts for ES query testing.
    
    **Erwartet / Beweis**
    
- Input sanitized/parameterized; no unexpected rows, no stack traces. Beweis: before/after responses, error logs.

**Mitigation**

- Parameterized queries, whitelist fields for sorting, limit allowed operators, validate query DSLs server-side.

---

### LD-04 — CSV/Export: CSV & Formula Injection

**WSTG-Mapping:** Data Export / Information Disclosure.

**Schritte**

1. Erzeuge Export (CSV/XLSX) via UI or API for items including attacker-controlled fields (z. B. `title`, `comment`).
2. Fülle Werte mit typical formula injection prefixes: `=CMD|' /C calc'!A0`, `+SUM(1,1)`, `1+1`, `@cmd`. Also `'"=1+1'` variants.
3. Öffne Export in Excel / LibreOffice and observe whether formula executes or remains as text.
4. Also test CSV with embedded newlines, separators, long fields, embedded HTTP links.

**Why it matters**

- Formulas can execute when file opened in spreadsheet apps causing code execution or data exfiltration (macroless but still dangerous).

**Expected / Beweis**

- Export sanitizes values (prefix `'` or whitespace) or escapes `=,+,-,@` so spreadsheet treats it inert. Evidence: exported CSV content + screenshot of opened sheet showing no formula execution.

**Mitigation**

- Sanitize export cells: prefix dangerous starting characters with `'` (apostrophe) or `\t`, or prepend `'=...` safe. Prefer CSV headers and content-type forcing download as attachment. For XLSX use safer cell types (string cell). Document this as a secure export policy.

---

### LD-05 — Large `offset` / `limit` → DoS / resource exhaustion

**WSTG-Mapping:** Performance / DoS testing.

**Schritte**

1. Call list endpoint with extreme values: `?limit=1000000&offset=0`, large negative, or very large offset `?limit=100&offset=10000000`.
2. Measure response time, CPU/memory (if you have instrumentation), DB query plan, and any timeouts.
3. Simulate many concurrent such requests to check resource exhaustion.
4. Test deep pagination via user UI (infinite scroll) with rapid requests.

**Automation-Hint**

- Simple Python scripts producing many requests, JMeter or vegeta for load test (only in authorized test environments).
    
    **Erwartet / Beweis**
    
- Server enforces sane caps (`limit` capped), returns 400/422 for insane values, cursor/pagination used for large datasets. Evidence: response codes, timing graphs, server logs.

**Mitigation**

- Use cursor-based pagination (opaque cursor tokens), max `limit` enforced, rate-limiting, query timeouts and backend query complexity limits, avoid deep offset where possible.

---

### LD-06 — Bulk endpoints: per-row ACL enforcement

**WSTG-Mapping:** Business logic / Authorization.

**Schritte**

1. Wenn API `POST /items/bulk-update` or `POST /items/import` verfügbar: craft a payload that includes rows touching other owners (set ownerId or privileged fields).
2. Submit and observe whether server applies changes for rows you aren't owner of.
3. Test CSV import with `role` or `is_private` toggles in rows.

**Erwartet / Beweis**

- Server validates each row per ownership; unauthorized row changes rejected. Evidence: import result logs, DB diffs.

**Mitigation**

- Per-row authorization checks, validation hooks, dry-run mode requiring review for privileged changes.

---

### LD-07 — Caching & Cache-Poisoning edge cases

**Schritte**

1. Prüfe cache headers (`Cache-Control`, `Vary`) on list/detail endpoints.
2. Versuche serve cached responses across users (e.g., request public cacheable URL with Authorization header omitted leading to accidental caching of private content).
3. Test CDN edge caching rules with auth cookies present.

**Erwartet / Beweis**

- Private endpoints not cacheable; Vary/Authorization respected; no PII served from cache to others. Evidence: cached responses, headers.

**Mitigation**

- Private content: `Cache-Control: no-store` or authenticated responses not cached at CDN/edge, set proper `Vary` rules.

---

## Tools & Beispiel-Payloads (nur in autorisierten Umgebungen)

- Tools: Burp Suite (Repeater/Intruder), curl/postman, ffuf/dirb, sqlmap (wenn injection vermutet), headless browser/Selenium (export handling), JMeter/vegeta for load tests, Excel/LibreOffice for export verification.
- CSV injection prefixes to test: `=`, `+`, , `@`. Beispielwerte: `=cmd|' /C calc'!A0`, `+SUM(1,1)`, `1+1`, `@cmd`.
- SQL/ES payload examples as appropriate: `' OR '1'='1` , `{"query":{"match_all":{}}}` for ES injection where applicable.

---

## Reporting-Template (Minimalfelder pro Finding)

- **TestID** (z. B. LD-04)
- **WSTG-Ref** (z. B. Input Validation / Data Export)
- **Kurzbeschreibung**
- **Reproduktionsschritte (raw req/res, payloads)**
- **Beweis (raw req/res, screenshots of open spreadsheet, logs)**
- **Severity (CVSS) + Business Impact**
- **Kurz-Fix** + Detaillierte Remediation
- **Temporäre Mitigation** (z. B. disable exports until fixed)

---

## Schnelle Gegenmaßnahmen (Kurz)

- Owner checks bei jedem CRUD-Action; zentrale Authorization-Middleware.
- Whitelist für sort/filter Parameter; parameterize queries; sanitize query parts.
- Sanitize export fields: prefix `'=`, `\t` or apostrophe for dangerous leading characters; use proper XLSX cell typing.
- Cursor-based pagination, cap `limit`, deny extreme `offset` values.
- Rate limiting & query timeouts; quota per IP/key.
- Per-row ACL for bulk endpoints; require dry-run + admin approval for mass changes.
- Mark private endpoints `Cache-Control: no-store` and secure CDN rules.

---