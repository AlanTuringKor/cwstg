# 9. Forms / Multi-step Flows

# Kapitel: Forms / Multi-step Flows

**Ziel**

Finde Schwachstellen in Multi-Step Formularen und Workflows (z. B. Checkout, Onboarding, Payment flows, Complex Wizards), insbesondere CSRF auf finalisierenden Aktionen, Logik-/State-Flaws (Step-Replay, Step-Skip), Client-Validation-Bypass und Manipulation von versteckten Feldern (amounts, roles, flags). Teste auch Wiederholbarkeit / Idempotenz und Race-Conditions zwischen Schritten.

**Scope / Prüfbereiche**

- CSRF token presence & validation across steps
- Server-side authoritative flow state vs client-provided state
- Hidden / disabled field tampering (client → server)
- Replay / resubmission / out-of-order step calls
- Idempotency & nonce usage for finalization (prevent double spend)
- Race conditions / concurrent finalization (double submit)
- Validation of invariants across steps (sum of amounts, totals)
- Logging / audit trail of flow changes
- Timeout / expiry of step tokens / partial flows

**WSTG-Mapping (relevante Bereiche — nutze diese bei Reporten)**

- *WSTG-SESS* / Session & CSRF tests — CSRF on state changing requests.
- *WSTG-BUSL / Business Logic* — Logic flaws, workflow misuse.
- *WSTG-INPV* — Input validation (hidden fields tamper).
- *WSTG-AUTH* — authentication/authorization checks for step actions (if roles change).
- *WSTG-LOG* — logging & monitoring of critical state changes.

---

## Testfälle (Kurzliste mit TestIDs)

- **MF-01** — CSRF on multi-step finalization (e.g., order confirm).
- **MF-02** — Tamper hidden inputs between steps (amounts, role flags, recipient).
- **MF-03** — Skip steps by calling later endpoint directly (bypass checks).
- **MF-04** — Replay/resubmit finalization (double submit / idempotency failure).
- **MF-05** — Race condition: concurrent finalization causing double charge or inconsistent state.
- **MF-06** — Missing server-side state validation (server trusts client step data).
- **MF-07** — Expired/long-lived step tokens allowing late replay.
- **MF-08** — Insufficient logging/audit of critical flow events.

---

## Detaillierte Testfälle — Schritte, Hints, Erwartetes Ergebnis

### MF-01 — CSRF on multi-step finalization

**WSTG-Mapping:** CSRF / session tests.

**Kurz-Schritte**

1. Reproduce full multi-step flow in a browser as an authenticated user up to the final submit (e.g., payment confirmation).
2. Capture requests (proxy). Identify CSRF protection mechanism: synchronizer token, double-submit cookie, custom header, referer check.
3. Build a PoC attacker page that sends a forged POST/PUT to the finalization endpoint while the victim is authenticated (auto-submitting form or XHR from another origin).
4. Vary Content-Type (form vs JSON/XHR) to test protections.
5. Observe whether the forged request succeeds.

**Automation-Hint**

- Use simple HTML PoC for form-based CSRF; use curl to replay with/without token; use Burp to replay and remove token.
    
    **Erwartetes Ergebnis / Beweis**
    
- Finalization fails without valid CSRF token or custom header; server rejects request (401/403). Evidence: PoC page + server response/logs showing rejection.
    
    **Schnelle Gegenmaßnahme**
    
- Require per-request synchronizer tokens for state-changing actions; verify token server-side; require custom header + SameSite cookies; require re-auth/MFA for high risk finalization.

---

### MF-02 — Tamper hidden inputs between steps (amounts, role flags)

**WSTG-Mapping:** Input Validation / Business Logic.

**Kurz-Schritte**

1. While performing flow, intercept step requests containing hidden fields (e.g., `amount`, `recipientId`, `isPremium=true`).
2. Modify those hidden fields and replay to next step or to finalization. Example: increase `amount` to negative or set `isAdmin` flag.
3. Observe: does server accept tampered values or revert to server-side authoritative data?

**Automation-Hint**

- Burp Repeater / Intruder for many permutations; scripts to modify JSON body fields.
    
    **Erwartetes Ergebnis / Beweis**
    
- Server ignores/rejects tampered client values or validates against server-side authoritative state; changes are not applied. Evidence: raw req/res, DB state comparison.
    
    **Schnelle Gegenmaßnahme**
    
- Do not trust client for authoritative fields; store canonical state server-side between steps; validate incoming values against server state and business invariants (e.g., `total == sum(items)`).

---

### MF-03 — Skip step by calling later endpoint directly

**WSTG-Mapping:** Business Logic / Flow control.

**Kurz-Schritte**

1. Identify step endpoints: step1 `/flow/step/1`, step2 `/flow/step/2`, finalize `/flow/finish`.
2. Without performing step1, call step2 or finalize endpoint directly (with session cookie).
3. Check response: does server perform actions or require step sequence?

**Automation-Hint**

- Use script to call endpoints in arbitrary order; monitor server responses & side effects.
    
    **Erwartetes Ergebnis / Beweis**
    
- Server enforces server-side flow state; calling out-of-order returns error (400/409) or requires replays of missing steps. Evidence: raw req/res + logs.
    
    **Schnelle Gegenmaßnahme**
    
- Keep server authoritative state machine with explicit step status (e.g., `flowId: {step: 1, status: pending}`) and validate allowed transitions.

---

### MF-04 — Replay / resubmit finalization (double submit / idempotency failure)

**WSTG-Mapping:** Business Logic / Idempotency.

**Kurz-Schritte**

1. Complete a flow to finalization (e.g., purchase). Capture final POST.
2. Replay the exact final request (same body/headers) multiple times.
3. Observe whether action is applied multiple times (multiple orders, double charge) or blocked by idempotency.

**Automation-Hint**

- Repeater to replay; for payment flows ensure authorized testing or use sandbox environment.
    
    **Erwartetes Ergebnis / Beweis**
    
- Server detects duplicate request via idempotency key or server-side transaction detection and rejects duplicates; no double effect. Evidence: request logs + DB showing only one order/charge.
    
    **Schnelle Gegenmaßnahme**
    
- Implement idempotency keys for finalizing requests (client generated or server generated and stored), or server-side deduplication based on unique business key + transaction atomicity.

---

### MF-05 — Race condition: concurrent finalization causing inconsistent state

**WSTG-Mapping:** Concurrency / Business Logic.

**Kurz-Schritte**

1. In a controlled environment, perform two concurrent finalization requests with same flowId (or two rapid clicks) — e.g., two admins accept same request concurrently.
2. Observe if duplicate side effects occur (double charge, double role grant) or DB corruption.
3. Analyze logs/transaction records for concurrency handling.

**Automation-Hint**

- Use multi-threaded script to fire requests with minimal offset. Use DB snapshots/transaction logs if available.
    
    **Erwartetes Ergebnis / Beweis**
    
- Server handles concurrency atomically (DB transactions, optimistic locking) and prevents double-side effects. Evidence: transaction logs, single resulting state.
    
    **Schnelle Gegenmaßnahme**
    
- Use DB transactions with appropriate isolation or optimistic locking (version fields), or centralized mutex for critical flow finalization.

---

### MF-06 — Missing server-side state validation (server trusts client step data)

**WSTG-Mapping:** Business Logic / Input Validation.

**Kurz-Schritte**

1. Compare server-stored intermediate state after each step (if obtainable via API) with client POSTs.
2. Modify client values to conflict with server stored state and observe if server overwrites canonical values.
3. Look for flows where client is allowed to rewrite entire flow state without server checks.

**Erwartetes Ergebnis / Beweis**

- Server only accepts diffs or server-validated updates; evidence: raw req/res, before/after state.
    
    **Schnelle Gegenmaßnahme**
    
- Keep canonical state server-side and verify all transitions; accept only allowed changes.

---

### MF-07 — Expired / long-lived step tokens allowing late replay

**WSTG-Mapping:** Session management & token expiry.

**Kurz-Schritte**

1. Start flow, get step tokens (if present) and wait for configured expiry (or attempt to use old token).
2. Try to resume after long delay using old tokens to see if server accepts them.
3. Test stolen token replay from another session.

**Erwartetes Ergebnis / Beweis**

- Tokens expire after configured TTL and are single-use; server rejects old tokens. Evidence: request responses and logs.
    
    **Schnelle Gegenmaßnahme**
    
- Use short TTLs, single-use tokens, tie tokens to session/client fingerprint and mark used tokens as consumed.

---

### MF-08 — Insufficient logging/audit of critical flow events

**WSTG-Mapping:** Logging & Monitoring.

**Schritte**

1. Execute authorized and unauthorized step changes and then inspect logs (if available) for actor, timestamp, old/new state.
2. Check whether failed tampering attempts are logged/alerted.

**Erwartetes Ergebnis / Beweis**

- All critical step changes and failures are logged with context and alerts for abnormal patterns. Evidence: log excerpts.
    
    **Schnelle Gegenmaßnahme**
    
- Log every change to authoritative flow state and failed tamper attempts; forward critical events to SIEM.

---

## Tools & Payload-Beispiele (nur in autorisierten Testumgebungen)

- Tools: Burp Suite (Proxy/Replayer/Intruder), curl, Postman, Selenium/Puppeteer (simulate UI multi-step), Python scripts (requests + threading), JMeter (concurrency), Mitmproxy for traffic tampering, browser devtools (modify hidden DOM fields).
- Example tamper payloads: change `"amount": 100 -> -100`, set `"isAdmin": false -> true"`, remove/alter CSRF token field, replay same `POST /flow/complete` twice.
- Idempotency tests: resend same request with/without `Idempotency-Key` header.

---

## Reporting-Template (Minimalfelder pro Finding)

- **TestID** (z. B. MF-02)
- **WSTG-Ref** (z. B. Business Logic / Input Validation / CSRF)
- **Kurzbeschreibung**
- **Reproduktionsschritte** (raw request(s) + sequence)
- **Beweis (raw req/res, screenshots, logs, DB change)**
- **Severity (CVSS) + Business Impact**
- **Kurz-Fix** + Detaillierte Remediation (state model, tokens, transactions)
- **Compensating controls** (e.g., temporary re-auth, disable feature)

---

## Schnelle Gegenmaßnahmen (Kurz)

- Implement server-side authoritative flow state (persist step status per flowId) and validate transitions.
- Use per-step single-use nonces / synchronizer tokens bound to session and flowId; verify server-side.
- Require CSRF protection on every state-changing endpoint (incl. intermediate steps if they change server state).
- Validate hidden/client fields against server canonical values; never trust client for amounts/roles.
- Use idempotency keys for finalization endpoints to prevent duplicate side-effects.
- Enforce short token TTL and mark tokens as consumed.
- Use DB transactions / optimistic locking or application mutex for finalization.
- Require re-authentication / step re-confirmation (or MFA) for high-risk finalization.
- Log all tamper attempts and failed transitions; alert on anomalies.

---

## Tiefergehende/Architektur-Empfehlungen

- Model flows as finite state machines stored server-side (flowId, currentStep, allowedNextSteps, lastUpdatedBy). Enforce transitions with server logic.
- Use signed server-side state snapshots (HMAC over canonical state) if you must store some state client-side — but prefer server storage.
- For payment flows: separate "prepare" and "commit" operations with explicit idempotency/confirmation steps and ledgered transactions.
- Automate unit/integration tests that simulate out-of-order steps, replays, and concurrency.
- Threat-model flows: identify steps that change sensitive state and require stronger protections (re-auth, MFA, manual approval).

---