# 7. Search / Filter

# Kapitel: Search / Filter

**Ziel**

Schutz der Such- und Filterfunktionen vor XSS, Injection in Query-Parser (SQL / NoSQL / Elasticsearch / Lucene), und vor DoS durch teure Suchanfragen oder regex-Abfragen. Sicherstellen, dass Eingaben sauber validiert, Abfragen sicher zusammengesetzt und Backend-Operationen begrenzt sind.

**Scope / Prüfbereiche**

Input-Sanitation, Query-DSL / Parser-Injection (SQL/NoSQL/Elastic/Lucene), Reflected & Stored XSS bei Darstellung von Suchbegriffen, Regex/complex query DoS, Rate-Limiting, Result-Sanitization/escaping, logging & monitoring für teure Abfragen.

**WSTG-Mapping (relevante Bereiche)**

- **WSTG-INPV** — Input Validation & Injection (prüft SQL/NoSQL/Query-DSL Injections).
- **WSTG-XSS** — Reflected/Stored XSS (wenn Suchbegriffe in UI gerendert werden).
- **WSTG-BUSL / Performance** — DoS/resource exhaustion via expensive queries.
- **WSTG-LOG** — Logging & Monitoring (teure/abnorme Queries detektieren).

---

## Testfälle (Kurzliste mit TestIDs)

- **SF-01** — Reflected XSS via search term rendering (Reflected/Stored).
- **SF-02** — Injection in search backend (SQL/NoSQL/Elasticsearch/Lucene).
- **SF-03** — Complex/regex queries causing CPU spike (ReDoS / heavy ES queries).
- **SF-04** — Parameter pollution / operator abuse (e.g., `or`, , wildcard abuse).
- **SF-05** — Result sanitization / query response header leakage (timings or debug info).
- **SF-06** — Rate limiting / abuse of paginated search to amplify load.

---

## Detaillierte Testfälle — Schritte, Hints, Erwartetes Ergebnis

### SF-01 — Reflected / Stored XSS via search term rendering

**WSTG-Mapping:** WSTG-XSS (Reflected/Stored).

**Kurz-Schritte**

1. Suche mit payloads in Eingabefeld `q` oder in Filter-Inputs: z. B. `<script>alert(1)</script>`, `"><img src=x onerror=alert(1)>`, `"><svg onload=alert(1)>`.
2. Prüfe Ergebnisseite: Wird Suchbegriff im HTML/DOM unescaped wiedergegeben (z. B. in „Ergebnisse für …“)?
3. Prüfe Stored-Variante: Falls Search-History oder „beliebte Suchbegriffe“ gespeichert werden, füge payload ein und öffne die Seite später als andere Rollen.
4. Variationen: HTML-encoding, URL-encoding, UTF-7/Unicode-obfuskation, SVG/attribute payloads, event handler attributes, CSS payloads.

**Automation-Hint**

- Selenium / headless Chrome zur Render-Erkennung; Burp + DOM-XSS Payload-List; DOMScanner zum Erkennen von script execution.
    
    **Erwartetes Ergebnis / Beweis**
    
- Alle Suchbegriffe werden escaped before rendering; keine JS-Ausführung; PoC: raw request + screenshot / screenrec der nicht-ausgeführten Payload.
    
    **Schnelle Gegenmaßnahme**
    
- Escape/encode beim Output (HTML-escape), Content-Security-Policy (CSP), serverseitiges Sanitizing, verwenden von textContent statt innerHTML in JS.

---

### SF-02 — Injection in search backend (SQL / NoSQL / Elastic / Lucene)

**WSTG-Mapping:** WSTG-INPV (SQL/NoSQL/Query DSL injection).

**Kurz-Schritte**

1. Identifiziere Backend (SQL, Mongo, Elasticsearch). Hinweise: error messages, response patterns, endpoints, request bodies.
2. Teste klassische SQLi payloads in `q` or filter params where SQL is likely used: `' OR '1'='1' --` , `admin' --`, time-based `' ; WAITFOR DELAY '0:0:5' --` (only in authorized contexts).
3. Für NoSQL (Mongo) teste payloads like `{"$ne": null}` in JSON params or `q[$where]=...`.
4. Für ES/Lucene teste query DSL injection attempts: inject `{"query":{"match_all":{}}}` or crafted Lucene operators (`:*`, `field:(*)`,  operators) into parameters that get embedded.
5. Observe errors, unexpected result expansions, or timing anomalies.

**Automation-Hint**

- sqlmap with recorded request for suspected SQL; custom scripts for NoSQL/ES injections; Burp Intruder for payload lists.
    
    **Erwartetes Ergebnis / Beweis**
    
- Backend läuft parameterized/escaped; injection attempts either cause safe rejection or sanitized query; no additional rows or backend errors. Evidence: request/response diffs, timing logs.
    
    **Schnelle Gegenmaßnahme**
    
- Parameterized queries/ prepared statements; whitelist allowed fields/operators; escape/validate Query DSL parts server-side; use query building libraries that avoid string concatenation.

---

### SF-03 — Expensive queries / regex causing CPU spike (ReDoS / heavy queries)

**WSTG-Mapping:** WSTG-BUSL / Performance testing.

**Kurz-Schritte**

1. Probe with expensive regex patterns in search input (if server applies regex): e.g., catastrophic backtracking patterns like `(a+)+$` variants adjusted to target engine.
2. For ES: attempt queries with `regexp`, `wildcard` or `prefix` on large fields; use leading wildcard `term` if allowed.
3. For SQL: test expensive `LIKE '%term%'`, complex joins via allowed filters (if possible).
4. Measure response times, CPU, memory and backend query plans if you have telemetry. Repeat with increasing payload complexity.
5. Simulate concurrent expensive queries to measure amplification.

**Automation-Hint**

- Use JMeter/vegeta for concurrent load; small scripts to escalate regex complexity; monitor response times & 5xx rates.
    
    **Erwartetes Ergebnis / Beweis**
    
- Query timeouts enforced; system returns 4xx/429 or controlled error for expensive query; backend protection prevents CPU spikes. Evidence: timing graphs, server logs, request traces.
    
    **Schnelle Gegenmaßnahme**
    
- Set backend timeouts & query complexity limits, disallow expensive operators, throttle regex usage, use cost-based query limiting, circuit breakers.

---

### SF-04 — Parameter pollution / operator abuse (wildcards, boolean operators)

**WSTG-Mapping:** Input Validation / Query logic.

**Kurz-Schritte**

1. Test wildcards: , `?`, leading wildcards (`term`) and operator combinations (`term OR other`).
2. Try parameter pollution: duplicate params (`q=foo&q=bar`) or injecting operator tokens into filters (`sort=created_at; DROP ...`) to see if parser concatenates dangerously.
3. Check whether search supports advanced query syntax (user docs / help) — if so, test escaping rules.

**Erwartetes Ergebnis / Beweis**

- Only allowed operators accepted; duplicates handled deterministically; no injection of operators. Evidence: request samples + server behavior.
    
    **Mitigation**
    
- Whitelist operators, escape user input when injected into parser, normalize multiple params, use structured query builders.

---

### SF-05 — Result sanitization / verbose result leakage (timings, debug info)

**WSTG-Mapping:** Information Leakage / Logging.

**Kurz-Schritte**

1. Observe API responses for debug fields, stack traces, query plans or hints.
2. Check response headers / body for timing info or internal IDs.
3. Inspect search result snippets for unescaped metadata that could leak secrets.

**Erwartetes Ergebnis / Beweis**

- No debug/plan info returned; no internal identifiers that expose backend structure; evidence: response dumps.
    
    **Mitigation**
    
- Strip debug info in production; normalize error responses; sanitize result snippet content.

---

### SF-06 — Rate limiting / pagination abuse on search endpoints

**WSTG-Mapping:** Authentication / Rate limiting & DoS mitigation.

**Kurz-Schritte**

1. Automate many search requests with varying query complexity and page sizes.
2. Attempt rapid page traversal (deep paging) and check server behaviour.
3. Test API Key / anonymous vs authenticated user thresholds.

**Erwartetes Ergebnis / Beweis**

- Rate limits applied per IP/user/API key; large page/deep paging triggers throttling; evidence: 429 responses + logs.
    
    **Mitigation**
    
- Implement per-client rate limiting, enforce max page sizes, use cursor paging, cache popular queries.

---

## Tools & Beispiel-Payloads (nur in autorisierten Tests)

- Tools: Burp Suite (Repeater/Intruder), sqlmap (for SQL suspected), custom scripts (Python Requests) to inject and measure timing, Selenium/headless for UI render checks, JMeter/vegeta for load tests, Elastic head/Dev tools only in safe environment.
- XSS payloads: `<script>alert(1)</script>`, `"><img src=x onerror=alert(1)>`, SVG payloads.
- SQL payloads: `' OR '1'='1' --`, time-based for DBMS (only with permission).
- ES/Lucene patterns: `:*`, `field:(*:* )`, `regexp` patterns.
- ReDoS candidate regexes: `(a+)+$` style constructs adjusted to engine.

---

## Reporting-Template (Minimalfelder pro Finding)

- **TestID** (z. B. SF-02)
- **WSTG-Ref** (z. B. WSTG-INPV / WSTG-XSS)
- **Kurzbeschreibung**
- **Reproduktionsschritte** (raw req/res, payload, user context)
- **Beweis (raw req/res, screenshots, timing graphs)**
- **Severity (CVSS) + Business Impact**
- **Kurz-Fix** + Detaillierte Remediation
- **Mitigation / temporary controls** (e.g., block operator, rate limit)

---

## Schnelle Gegenmaßnahmen (Kurz)

- Escape/encode alle Suchbegriffe beim Rendering (prevent XSS).
- Verwende parameterized query builders / structured query APIs statt String-Konkatenation.
- Whitelist erlaubter Query-Operatoren und Feldnamen; validiere Query-DSL Teile server-side.
- Setze Backend-Query-Timeouts, node/ES query complexity limits; disallow expensive operations (`regexp`, leading wildcards) oder require elevated rights.
- Implementiere rate-limiting per IP/user/API key, use caching for common queries, use cursor-based pagination for large datasets.
- Log & alert on unusual query complexity or resource use.

## Tiefergehende Empfehlungen (Architektur / Process)

- Query gateway / proxy mit cost-estimation (rechne estimated cost and reject expensive queries).
- Instrumentation: expose query traces to SIEM and set thresholds for auto-throttling.
- For full-text search, separate indexing user-provided text from query DSL; provide safe, high-level filter APIs instead of exposing raw DSL to clients.
- Security review of any feature that exposes advanced search syntax to end users.

---